//! WASM executor with support for multiple WASI versions
//!
//! This module provides execution for different WASM formats:
//! - WASI Preview 2 (P2): Modern component model with HTTP support
//! - WASI Preview 1 (P1): Standard WASI modules
//!
//! ## Adding New Build Targets
//!
//! To add support for a new build target (e.g., wasm32-unknown-unknown):
//!
//! 1. Create a new module file: `src/executor/wasi_unknown.rs`
//! 2. Implement the executor function with signature:
//!    ```rust,ignore
//!    pub async fn execute(
//!        wasm_bytes: &[u8],
//!        input_data: &[u8],
//!        limits: &ResourceLimits,
//!        env_vars: Option<HashMap<String, String>>,
//!        ctx: Option<&ExecutionContext>,
//!    ) -> Result<(Vec<u8>, u64)>
//!    ```
//! 3. Add module declaration: `mod wasi_unknown;`
//! 4. Add detection logic in `execute_async()` to try loading the new format
//! 5. Add unit tests in `tests/` directory
//!
//! ## Architecture
//!
//! The executor tries formats in order of priority:
//! 1. WASI P2 component (most modern, has HTTP)
//! 2. WASI P1 module (standard, widely compatible)
//! 3. Return error if no format matches

use anyhow::Result;
use std::collections::HashMap;
use std::sync::Arc;
use std::time::Instant;
use tracing::{info, warn};

use crate::api_client::{ExecutionOutput, ExecutionResult, ResourceLimits, ResponseFormat};
use crate::outlayer_rpc::RpcProxy;
use crate::outlayer_storage::client::StorageConfig;

mod wasi_p1;
mod wasi_p2;

/// Validate that WASM has required metadata export when running in project context
///
/// WASM running in a project context MUST have `__outlayer_get_metadata` export.
/// This ensures cleanup functions are available for data deletion.
///
/// # Arguments
/// * `has_metadata_export` - Whether the WASM has the metadata export
/// * `storage_config` - Storage configuration (contains project_uuid if running as project)
///
/// # Returns
/// * `Ok(())` - Validation passed (not a project, or has required export)
/// * `Err(_)` - Running as project but missing required export
pub fn validate_project_metadata(
    has_metadata_export: bool,
    storage_config: Option<&StorageConfig>,
) -> Result<()> {
    // Check if running as project (storage_config exists means we have a project)
    let is_project = storage_config.is_some();

    if is_project && !has_metadata_export {
        anyhow::bail!(
            "WASM running in project context must have `__outlayer_get_metadata` export.\n\
            This export is generated by the `outlayer::metadata!` macro.\n\
            Without this export, cleanup functions are unavailable and data deletion is impossible.\n\
            \n\
            To fix:\n\
            1. Add `outlayer` crate to your dependencies\n\
            2. Use the metadata macro:\n\
               outlayer::metadata! {{\n\
                   project: \"your.near/project-name\",\n\
                   version: \"1.0.0\",\n\
               }}\n\
            \n\
            Or run this WASM as standalone (without project) if you don't need persistent storage."
        );
    }

    if is_project && has_metadata_export {
        tracing::debug!("‚úÖ Project WASM has __outlayer_get_metadata export");
    }

    Ok(())
}

/// Execution context with optional dependencies for WASM execution
///
/// This struct holds external services that WASM code can use through host functions.
/// Currently supports:
/// - RPC Proxy: Allows WASM to make NEAR RPC calls without exposing API keys
/// - Storage: Persistent storage for projects and standalone WASM
///
/// Future extensions might include:
/// - External API clients
/// - Metrics/logging services
#[derive(Clone)]
pub struct ExecutionContext {
    /// RPC proxy for NEAR blockchain access (only used in WASI P2)
    pub outlayer_rpc: Option<Arc<RpcProxy>>,
    /// Storage configuration for persistent storage (only used in WASI P2)
    pub storage_config: Option<StorageConfig>,
    /// Tokio runtime handle for async operations in host functions
    pub runtime_handle: tokio::runtime::Handle,
}

impl ExecutionContext {
    /// Create a new execution context
    #[allow(dead_code)]
    pub fn new(runtime_handle: tokio::runtime::Handle) -> Self {
        Self {
            outlayer_rpc: None,
            storage_config: None,
            runtime_handle,
        }
    }

    /// Create context with RPC proxy
    #[allow(dead_code)]
    pub fn with_outlayer_rpc(mut self, proxy: RpcProxy) -> Self {
        self.outlayer_rpc = Some(Arc::new(proxy));
        self
    }

    /// Create context with storage config
    #[allow(dead_code)]
    pub fn with_storage(mut self, config: StorageConfig) -> Self {
        self.storage_config = Some(config);
        self
    }

    /// Check if RPC proxy is available
    #[allow(dead_code)]
    pub fn has_outlayer_rpc(&self) -> bool {
        self.outlayer_rpc.is_some()
    }

    /// Check if storage is available
    #[allow(dead_code)]
    pub fn has_storage(&self) -> bool {
        self.storage_config.is_some()
    }
}

/// Metadata from WASM's `__outlayer_get_metadata` export
#[derive(Debug, Clone, serde::Deserialize)]
pub struct WasmMetadata {
    pub project: String,
    pub version: String,
}

/// Extract metadata from WASM if it has `__outlayer_get_metadata` export
///
/// This function creates a minimal wasmtime instance just to call the metadata export.
/// Returns None if the export doesn't exist or returns invalid data.
pub fn extract_metadata(wasm_bytes: &[u8]) -> Option<WasmMetadata> {
    use wasmtime::*;

    // Create engine with minimal config
    let mut config = Config::new();
    config.wasm_component_model(true);

    let engine = match Engine::new(&config) {
        Ok(e) => e,
        Err(_) => return None,
    };

    // Try as component first (P2)
    if let Ok(component) = wasmtime::component::Component::new(&engine, wasm_bytes) {
        // Check if has the export
        let component_type = component.component_type();
        for (name, _) in component_type.exports(&engine) {
            if name == "__outlayer_get_metadata" {
                tracing::debug!("Found __outlayer_get_metadata in P2 component");
                // TODO: Actually call the export - requires full linker setup
                // For now just check existence
                return None;
            }
        }
    }

    // Try as module (P1)
    if let Ok(module) = Module::new(&engine, wasm_bytes) {
        for export in module.exports() {
            if export.name() == "__outlayer_get_metadata" {
                tracing::debug!("Found __outlayer_get_metadata in P1 module");

                // Create minimal store and instance to call the export
                let mut store = Store::new(&engine, ());
                let instance = match Instance::new(&mut store, &module, &[]) {
                    Ok(i) => i,
                    Err(_) => return None,
                };

                // Get the function
                let func = match instance.get_func(&mut store, "__outlayer_get_metadata") {
                    Some(f) => f,
                    None => return None,
                };

                // Call it - should return pointer to static string
                let results = &mut [Val::I32(0)];
                if func.call(&mut store, &[], results).is_err() {
                    return None;
                }

                // Get pointer and read the string from memory
                let ptr = match results[0] {
                    Val::I32(p) => p as usize,
                    _ => return None,
                };

                let memory = match instance.get_memory(&mut store, "memory") {
                    Some(m) => m,
                    None => return None,
                };

                // Read null-terminated string from memory
                let data = memory.data(&store);
                if ptr >= data.len() {
                    return None;
                }

                // Find end of string (looking for closing brace or max 1KB)
                let max_len = std::cmp::min(1024, data.len() - ptr);
                let end = data[ptr..ptr + max_len].iter().position(|&b| b == 0 || b == b'}');
                let json_len = match end {
                    Some(pos) if data[ptr + pos] == b'}' => pos + 1,
                    Some(pos) => pos,
                    None => max_len,
                };

                let json_str = match std::str::from_utf8(&data[ptr..ptr + json_len]) {
                    Ok(s) => s,
                    Err(_) => return None,
                };

                tracing::debug!("Metadata JSON: {}", json_str);

                // Parse metadata
                match serde_json::from_str::<WasmMetadata>(json_str) {
                    Ok(meta) => {
                        tracing::info!("Extracted WASM metadata: project={}, version={}", meta.project, meta.version);
                        return Some(meta);
                    }
                    Err(e) => {
                        tracing::warn!("Failed to parse metadata JSON: {}", e);
                        return None;
                    }
                }
            }
        }
    }

    None
}

/// WASM executor supporting multiple WASI versions
pub struct Executor {
    /// Maximum instructions allowed per execution (default)
    _default_max_instructions: u64,
    /// Print WASM stderr to worker logs
    print_wasm_stderr: bool,
    /// Execution context with optional RPC proxy and other services
    context: Option<ExecutionContext>,
}

impl Executor {
    /// Create a new executor
    pub fn new(default_max_instructions: u64, print_wasm_stderr: bool) -> Self {
        Self {
            _default_max_instructions: default_max_instructions,
            print_wasm_stderr,
            context: None,
        }
    }

    /// Create executor with execution context
    #[allow(dead_code)]
    pub fn with_context(mut self, context: ExecutionContext) -> Self {
        self.context = Some(context);
        self
    }

    /// Execute WASM with input data
    ///
    /// Returns ExecutionResult with success/failure and optional output
    ///
    /// # Arguments
    /// * `wasm_bytes` - WASM binary to execute
    /// * `input_data` - Input data passed to WASM via stdin
    /// * `limits` - Resource limits for execution
    /// * `env_vars` - Environment variables (from secrets)
    /// * `build_target` - Build target (wasm32-wasip1, wasm32-wasip2)
    /// * `response_format` - Output format (Bytes, Text, Json)
    /// * `storage_config` - Optional per-execution storage config (overrides context)
    pub async fn execute(
        &self,
        wasm_bytes: &[u8],
        input_data: &[u8],
        limits: &ResourceLimits,
        env_vars: Option<HashMap<String, String>>,
        build_target: Option<&str>,
        response_format: &ResponseFormat,
        storage_config: Option<StorageConfig>,
    ) -> Result<ExecutionResult> {
        info!(
            "Starting WASM execution: {} instructions, {} MB memory, {} seconds, target: {:?}, format: {:?}",
            limits.max_instructions, limits.max_memory_mb, limits.max_execution_seconds, build_target, response_format
        );

        let start = Instant::now();

        // Try to execute with different WASI versions
        let result = self.execute_async(wasm_bytes, input_data, limits, env_vars, build_target, storage_config).await;

        let execution_time_ms = start.elapsed().as_millis() as u64;

        match result {
            Ok((output_bytes, instructions)) => {
                info!(
                    "WASM execution succeeded in {} ms, consumed {} instructions",
                    execution_time_ms, instructions
                );
                info!("üì¶ Raw output size: {} bytes", output_bytes.len());

                if output_bytes.is_empty() {
                    warn!("‚ö†Ô∏è WASM produced empty output (stdout was empty)");
                }

                // Convert output based on requested format
                let output = match response_format {
                    ResponseFormat::Bytes => {
                        Some(ExecutionOutput::Bytes(output_bytes))
                    }
                    ResponseFormat::Text => {
                        let text = String::from_utf8(output_bytes)
                            .unwrap_or_else(|e| format!("Invalid UTF-8 output: {}", e));
                        Some(ExecutionOutput::Text(text))
                    }
                    ResponseFormat::Json => {
                        // Parse output as JSON
                        match serde_json::from_slice::<serde_json::Value>(&output_bytes) {
                            Ok(json_value) => {
                                Some(ExecutionOutput::Json(json_value))
                            }
                            Err(e) => {
                                // If JSON parsing fails, return error
                                return Ok(ExecutionResult {
                                    success: false,
                                    output: None,
                                    error: Some(format!(
                                        "Failed to parse output as JSON: {}. Output was: {}",
                                        e,
                                        String::from_utf8_lossy(&output_bytes)
                                    )),
                                    execution_time_ms,
                                    instructions,
                                    compile_time_ms: None, // Compilation not tracked in executor
                                    compilation_note: None,
                                });
                            }
                        }
                    }
                };

                Ok(ExecutionResult {
                    success: true,
                    output,
                    error: None,
                    execution_time_ms,
                    instructions,
                    compile_time_ms: None, // Compilation not tracked in executor
                    compilation_note: None,
                })
            }
            Err(e) => {
                info!("WASM execution failed: {}", e);
                Ok(ExecutionResult {
                    success: false,
                    output: None,
                    error: Some(e.to_string()),
                    execution_time_ms,
                    instructions: 0,
                    compile_time_ms: None, // Compilation not tracked in executor
                    compilation_note: None,
                })
            }
        }
    }

    /// Try to execute WASM with different formats
    ///
    /// If build_target is known, try that format first for performance.
    /// Otherwise, try all formats in priority order.
    ///
    /// Priority order:
    /// 1. WASI Preview 2 component (HTTP, modern features, RPC proxy)
    /// 2. WASI Preview 1 module (standard WASI)
    /// 3. Error if no format matches
    async fn execute_async(
        &self,
        wasm_bytes: &[u8],
        input_data: &[u8],
        limits: &ResourceLimits,
        env_vars: Option<HashMap<String, String>>,
        build_target: Option<&str>,
        storage_config: Option<StorageConfig>,
    ) -> Result<(Vec<u8>, u64)> {
        // Create effective execution context with storage_config override
        let effective_ctx: Option<ExecutionContext> = if let Some(storage_cfg) = storage_config {
            // Create new context with storage config (merge with existing if present)
            if let Some(ref base_ctx) = self.context {
                Some(ExecutionContext {
                    outlayer_rpc: base_ctx.outlayer_rpc.clone(),
                    storage_config: Some(storage_cfg),
                    runtime_handle: base_ctx.runtime_handle.clone(),
                })
            } else {
                // No base context, create minimal one with just storage
                Some(ExecutionContext {
                    outlayer_rpc: None,
                    storage_config: Some(storage_cfg),
                    runtime_handle: tokio::runtime::Handle::current(),
                })
            }
        } else {
            // No override, use existing context as-is
            self.context.clone()
        };

        // Optimize: if we know build_target, try appropriate executor first
        if let Some(target) = build_target {
            tracing::debug!("üéØ Build target specified: {:?}", target);
            match target {
                "wasm32-wasip2" => {
                    tracing::debug!("üîπ Trying WASI P2 executor (target: wasm32-wasip2)");
                    // When target is known, return error directly (don't fallback to other formats)
                    // Pass execution context (RPC proxy + storage) to P2 executor
                    return wasi_p2::execute(
                        wasm_bytes,
                        input_data,
                        limits,
                        env_vars,
                        self.print_wasm_stderr,
                        effective_ctx.as_ref(),
                    ).await;
                }
                "wasm32-wasip1" | "wasm32-wasi" => {
                    tracing::debug!("üîπ Trying WASI P1 executor (target: {})", target);
                    // When target is known, return error directly (don't fallback to other formats)
                    // P1 does not support RPC proxy or storage (no component model), but we pass storage_config for metadata validation
                    let storage_cfg = effective_ctx.as_ref().and_then(|ctx| ctx.storage_config.as_ref());
                    return wasi_p1::execute(wasm_bytes, input_data, limits, env_vars, self.print_wasm_stderr, storage_cfg).await;
                }
                _ => {
                    tracing::debug!("‚ö†Ô∏è Unknown target '{}', fallback to auto-detection", target);
                    // Unknown target, fallback to auto-detection below
                }
            }
        } else {
            tracing::debug!("üîç No build target specified, auto-detecting format");
        }

        // Fallback: auto-detect format (for unknown targets or if specific executor failed)
        // Try WASI P2 component first (with RPC proxy and storage support)
        if let Ok(result) = wasi_p2::execute(
            wasm_bytes,
            input_data,
            limits,
            env_vars.clone(),
            self.print_wasm_stderr,
            effective_ctx.as_ref(),
        ).await
        {
            return Ok(result);
        }

        // Try WASI P1 module (no RPC proxy or storage, but validate metadata if project)
        let storage_cfg = effective_ctx.as_ref().and_then(|ctx| ctx.storage_config.as_ref());
        if let Ok(result) = wasi_p1::execute(wasm_bytes, input_data, limits, env_vars.clone(), self.print_wasm_stderr, storage_cfg).await
        {
            return Ok(result);
        }

        // If nothing worked, return error
        anyhow::bail!(
            "Failed to load WASM binary: not a valid WASI P2 component or WASI P1 module.\n\
             Build target: {:?}\n\
             Supported formats:\n\
             - WASI Preview 2 components (wasm32-wasip2)\n\
             - WASI Preview 1 modules (wasm32-wasip1, wasm32-wasi)\n\
             \n\
             If you need to add support for a new target, see module documentation.",
            build_target
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_executor_creation() {
        let executor = Executor::new(10_000_000_000, false);
        assert_eq!(executor._default_max_instructions, 10_000_000_000);
        assert_eq!(executor.print_wasm_stderr, false);
    }
}
