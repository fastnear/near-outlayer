//! GitHub Path Canonicalization Tests
//!
//! Verifies that path traversal attacks are prevented when processing GitHub repo paths.
//!
//! **Integration Tests**: These tests verify the PRODUCTION github_canon.rs module
//! from coordinator/src/github_canon.rs, copied here for integration testing.

use anyhow::{anyhow, Result};

// NOTE: These functions are copied from coordinator/src/github_canon.rs
// to simulate production behavior in integration tests.

/// Normalize GitHub URL to canonical form - Production implementation
///
/// Examples:
/// - `github.com/user/repo` → `https://github.com/user/repo`
/// - `https://github.com/user/repo.git` → `https://github.com/user/repo`
/// - `git@github.com:user/repo.git` → `https://github.com/user/repo`
fn normalize_github_url(url: &str) -> Result<String> {
    let url = url.trim();

    // 1. Convert SSH URL to HTTPS
    let url = if url.starts_with("git@github.com:") {
        url.replace("git@github.com:", "https://github.com/")
    } else if url.starts_with("github.com/") {
        format!("https://{}", url)
    } else if url.starts_with("http://github.com/") {
        url.replace("http://", "https://")
    } else {
        url.to_string()
    };

    // 2. Strip trailing slashes first
    let url = url.trim_end_matches('/');

    // 3. Strip .git suffix
    let url = url.strip_suffix(".git").unwrap_or(&url);

    // 4. Validate it's a GitHub URL
    if !url.starts_with("https://github.com/") {
        return Err(anyhow!(
            "Only GitHub repositories are supported (got: {})",
            url
        ));
    }

    // 5. Validate format: https://github.com/{owner}/{repo}
    let parts: Vec<&str> = url
        .strip_prefix("https://github.com/")
        .unwrap()
        .split('/')
        .collect();
    if parts.len() < 2 {
        return Err(anyhow!(
            "Invalid GitHub URL format (expected: https://github.com/owner/repo, got: {})",
            url
        ));
    }

    let owner = parts[0];
    let repo = parts[1];

    if owner.is_empty() || repo.is_empty() {
        return Err(anyhow!("Repository owner and name cannot be empty"));
    }

    // 6. Reconstruct canonical URL
    let canonical = format!("https://github.com/{}/{}", owner, repo);

    Ok(canonical)
}

/// Validate build path (prevent directory traversal) - Production implementation
fn validate_build_path(path: &str) -> Result<String> {
    let path = path.trim();

    // 1. Reject empty paths
    if path.is_empty() {
        return Err(anyhow!("Build path cannot be empty"));
    }

    // 2. Reject absolute paths
    if path.starts_with('/') {
        return Err(anyhow!("Build path must be relative (got: {})", path));
    }

    // 3. Reject path traversal attempts
    if path.contains("..") {
        return Err(anyhow!(
            "Build path cannot contain '..' (path traversal attempt: {})",
            path
        ));
    }

    // 4. Reject hidden directories (common attack vector)
    if path.starts_with('.') {
        return Err(anyhow!("Build path cannot start with '.' (got: {})", path));
    }

    // 5. Normalize slashes
    let normalized = path.replace('\\', "/");

    Ok(normalized)
}

#[cfg(test)]
mod tests {
    use super::*;

    // ========================================
    // Test 1: GitHub URL Normalization
    // ========================================

    #[test]
    fn test_normalize_github_url_https() -> Result<()> {
        // Standard HTTPS URLs
        let result = normalize_github_url("https://github.com/user/repo")?;
        assert_eq!(result, "https://github.com/user/repo");

        // With .git suffix
        let result = normalize_github_url("https://github.com/user/repo.git")?;
        assert_eq!(result, "https://github.com/user/repo");

        // With trailing slash
        let result = normalize_github_url("https://github.com/user/repo/")?;
        assert_eq!(result, "https://github.com/user/repo");

        println!("✓ HTTPS URL normalization works");
        Ok(())
    }

    #[test]
    fn test_normalize_github_url_http() -> Result<()> {
        // HTTP should be upgraded to HTTPS
        let result = normalize_github_url("http://github.com/user/repo")?;
        assert_eq!(result, "https://github.com/user/repo");

        println!("✓ HTTP → HTTPS upgrade works");
        Ok(())
    }

    #[test]
    fn test_normalize_github_url_ssh() -> Result<()> {
        // SSH URLs should be converted to HTTPS
        let result = normalize_github_url("git@github.com:user/repo.git")?;
        assert_eq!(result, "https://github.com/user/repo");

        println!("✓ SSH → HTTPS conversion works");
        Ok(())
    }

    #[test]
    fn test_normalize_github_url_short_form() -> Result<()> {
        // Short form without protocol
        let result = normalize_github_url("github.com/user/repo")?;
        assert_eq!(result, "https://github.com/user/repo");

        println!("✓ Short form normalization works");
        Ok(())
    }

    #[test]
    fn test_normalize_github_url_rejects_non_github() {
        // GitLab
        let result = normalize_github_url("https://gitlab.com/user/repo");
        assert!(result.is_err(), "Should reject GitLab URLs");

        // Bitbucket
        let result = normalize_github_url("https://bitbucket.org/user/repo");
        assert!(result.is_err(), "Should reject Bitbucket URLs");

        // Generic git server
        let result = normalize_github_url("https://git.example.com/user/repo");
        assert!(result.is_err(), "Should reject non-GitHub URLs");

        println!("✓ Non-GitHub URLs rejected");
    }

    #[test]
    fn test_normalize_github_url_invalid_format() {
        // Missing repo name
        let result = normalize_github_url("https://github.com/user");
        assert!(result.is_err(), "Should reject URL without repo name");

        // Missing owner
        let result = normalize_github_url("https://github.com/");
        assert!(result.is_err(), "Should reject URL without owner");

        // Empty owner/repo
        let result = normalize_github_url("https://github.com//");
        assert!(result.is_err(), "Should reject empty owner/repo");

        println!("✓ Invalid URL formats rejected");
    }

    // ========================================
    // Test 2: Build Path Validation
    // ========================================

    #[test]
    fn test_validate_build_path_normal() -> Result<()> {
        // Normal relative paths
        let result = validate_build_path("src/main.rs")?;
        assert_eq!(result, "src/main.rs");

        let result = validate_build_path("examples/hello-world")?;
        assert_eq!(result, "examples/hello-world");

        let result = validate_build_path("foo/bar/baz/qux.toml")?;
        assert_eq!(result, "foo/bar/baz/qux.toml");

        println!("✓ Normal relative paths accepted");
        Ok(())
    }

    #[test]
    fn test_validate_build_path_traversal_blocked() {
        // Classic path traversal attacks
        let malicious_paths = vec![
            "../../../etc/passwd",
            "foo/../../secrets/key.pem",
            "../.ssh/id_rsa",
            "normal/../../../root/.bashrc",
            "src/../../../proc/self/environ",
        ];

        for path in malicious_paths {
            let result = validate_build_path(path);
            assert!(
                result.is_err(),
                "Path traversal should be blocked: {}",
                path
            );
        }

        println!("✓ Path traversal attacks blocked");
    }

    #[test]
    fn test_validate_build_path_absolute_blocked() {
        // Absolute paths should be rejected
        let absolute_paths = vec![
            "/etc/passwd",
            "/home/user/.ssh/id_rsa",
            "/var/secrets/api_key",
            "/proc/self/environ",
        ];

        for path in absolute_paths {
            let result = validate_build_path(path);
            assert!(
                result.is_err(),
                "Absolute path should be rejected: {}",
                path
            );
        }

        println!("✓ Absolute paths rejected");
    }

    #[test]
    fn test_validate_build_path_hidden_files_blocked() {
        // Hidden files/directories (common attack vector)
        let hidden_paths = vec![
            ".env",
            ".git/config",
            ".ssh/id_rsa",
            ".aws/credentials",
            ".docker/config.json",
        ];

        for path in hidden_paths {
            let result = validate_build_path(path);
            assert!(
                result.is_err(),
                "Hidden file/directory should be rejected: {}",
                path
            );
        }

        println!("✓ Hidden files/directories rejected");
    }

    #[test]
    fn test_validate_build_path_empty_rejected() {
        let result = validate_build_path("");
        assert!(result.is_err(), "Empty path should be rejected");

        let result = validate_build_path("   ");
        assert!(result.is_err(), "Whitespace-only path should be rejected");

        println!("✓ Empty paths rejected");
    }

    #[test]
    fn test_validate_build_path_backslash_normalization() -> Result<()> {
        // Windows-style backslashes should be normalized to forward slashes
        let result = validate_build_path("src\\main.rs")?;
        assert_eq!(result, "src/main.rs");

        let result = validate_build_path("examples\\hello\\world.rs")?;
        assert_eq!(result, "examples/hello/world.rs");

        println!("✓ Backslash normalization works");
        Ok(())
    }

    // ========================================
    // Test 3: Encoded Traversal Attacks
    // ========================================

    #[test]
    fn test_validate_build_path_url_encoded_traversal() {
        // URL-encoded path traversal
        let encoded_paths = vec![
            "%2e%2e%2f%2e%2e%2fetc%2fpasswd", // URL-encoded ../../../etc/passwd
            "..%2f..%2fetc%2fpasswd",          // Partially encoded
        ];

        for path in encoded_paths {
            // Decode the path
            let decoded = path
                .replace("%2e", ".")
                .replace("%2E", ".")
                .replace("%2f", "/")
                .replace("%2F", "/");

            let result = validate_build_path(&decoded);
            assert!(
                result.is_err(),
                "URL-encoded traversal should be blocked after decoding: {}",
                decoded
            );
        }

        println!("✓ URL-encoded traversal blocked");
    }

    #[test]
    fn test_validate_build_path_double_encoded() {
        // Double-encoded traversal (less common but possible)
        let double_encoded = "..%252f..%252fetc%252fpasswd";

        // First decode
        let first_decode = double_encoded.replace("%252f", "%2f").replace("%252F", "%2F");
        // Second decode
        let second_decode = first_decode.replace("%2f", "/").replace("%2F", "/");

        let result = validate_build_path(&second_decode);
        assert!(
            result.is_err(),
            "Double-encoded traversal should be blocked: {}",
            second_decode
        );

        println!("✓ Double-encoded traversal blocked");
    }

    // ========================================
    // Test 4: Edge Cases and Boundaries
    // ========================================

    #[test]
    fn test_validate_build_path_single_dot_allowed() -> Result<()> {
        // Single dot in filename (not path component) is OK
        let result = validate_build_path("src/config.yaml")?;
        assert_eq!(result, "src/config.yaml");

        let result = validate_build_path("data/file.name.with.dots.txt")?;
        assert_eq!(result, "data/file.name.with.dots.txt");

        println!("✓ Single dots in filenames allowed");
        Ok(())
    }

    #[test]
    fn test_validate_build_path_two_dots_anywhere_blocked() {
        // Two consecutive dots anywhere in path should be blocked
        let paths_with_dots = vec![
            "src/..config", // Starts with ..
            "src/config..", // Ends with ..
            "src..backup",  // In middle
        ];

        for path in paths_with_dots {
            let result = validate_build_path(path);
            assert!(
                result.is_err(),
                "Path with '..' should be blocked: {}",
                path
            );
        }

        println!("✓ Two consecutive dots blocked in any position");
    }

    #[test]
    fn test_validate_build_path_unicode_paths() -> Result<()> {
        // Unicode characters in filenames are OK (not an attack)
        let result = validate_build_path("src/日本語.rs")?;
        assert_eq!(result, "src/日本語.rs");

        let result = validate_build_path("examples/привет/世界.txt")?;
        assert_eq!(result, "examples/привет/世界.txt");

        println!("✓ Unicode paths allowed");
        Ok(())
    }

    #[test]
    fn test_validate_build_path_very_long_paths() -> Result<()> {
        // Very long but valid paths should work
        let long_path = format!("src/{}/main.rs", "a".repeat(200));
        let result = validate_build_path(&long_path)?;
        assert_eq!(result, long_path);

        println!("✓ Long paths accepted (if valid)");
        Ok(())
    }

    // ========================================
    // Test 5: Cache Bypass Prevention
    // ========================================

    #[test]
    fn test_normalize_github_url_cache_bypass_prevention() -> Result<()> {
        // All these variations should normalize to the same canonical form
        let variations = vec![
            "https://github.com/user/repo",
            "https://github.com/user/repo.git",
            "https://github.com/user/repo/",
            "https://github.com/user/repo.git/",
            "http://github.com/user/repo",
            "github.com/user/repo",
            "git@github.com:user/repo.git",
        ];

        let canonical = "https://github.com/user/repo";

        for variation in variations {
            let result = normalize_github_url(variation)?;
            assert_eq!(
                result, canonical,
                "Variation '{}' should normalize to '{}'",
                variation, canonical
            );
        }

        println!("✓ Cache bypass prevention works (all variations → same canonical form)");
        Ok(())
    }
}
