//! Procedural macros for OutLayer SDK
//!
//! This crate provides the `metadata!` macro used to declare OutLayer project metadata.

use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, Ident, LitStr, Token};

/// Metadata declaration for OutLayer projects
///
/// This macro generates the required `__outlayer_get_metadata` export and cleanup functions.
/// WASM running in a project context **MUST** use this macro, otherwise execution will fail.
///
/// # Usage
///
/// ```rust,ignore
/// use outlayer::metadata;
///
/// metadata! {
///     project: "alice.near/my-app",
///     version: "1.0.0",
/// }
/// ```
///
/// # Generated Exports
///
/// This macro generates the following exports:
///
/// - `__outlayer_get_metadata()` - Returns JSON with project info
/// - `__outlayer_clear_all_storage()` - Clears all storage for this project
/// - `__outlayer_clear_storage_for_version(wasm_hash)` - Clears storage for specific version
///
/// # Why Is This Required?
///
/// Projects with persistent storage need cleanup functions. When a project is deleted,
/// the contract calls `__outlayer_clear_all_storage` to remove all stored data.
/// Without this export, data becomes orphaned and cannot be deleted.
#[proc_macro]
pub fn metadata(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as MetadataInput);

    let project = &input.project;
    let version = &input.version;

    let expanded = quote! {
        /// OutLayer metadata - DO NOT REMOVE
        ///
        /// This module is generated by `outlayer::metadata!` macro.
        /// It provides required exports for project-based execution.
        mod __outlayer_metadata {
            /// The project ID this WASM was built for
            pub const PROJECT_ID: &str = #project;

            /// The version of this WASM
            pub const VERSION: &str = #version;

            /// Returns project metadata as JSON
            ///
            /// Returns a pointer to a static string containing JSON metadata.
            /// Format: `{"project":"...", "version":"..."}`
            #[no_mangle]
            #[export_name = "__outlayer_get_metadata"]
            pub extern "C" fn get_metadata() -> *const u8 {
                static METADATA: &str = concat!(
                    r#"{"project":""#, #project, r#"","version":""#, #version, r#""}"#
                );
                METADATA.as_ptr()
            }

            /// Clears all storage for this project/account
            /// Called when project is deleted
            #[no_mangle]
            #[export_name = "__outlayer_clear_all_storage"]
            pub extern "C" fn clear_all_storage() {
                // Use the SDK storage module to clear all storage
                let _ = ::outlayer::storage::clear_all();
            }

            /// Clears storage for a specific WASM version
            /// Called when a version is removed from project
            #[no_mangle]
            #[export_name = "__outlayer_clear_storage_for_version"]
            pub extern "C" fn clear_storage_for_version(wasm_hash_ptr: *const u8, wasm_hash_len: usize) {
                // Safety: we trust the host to pass valid pointers
                let wasm_hash = unsafe {
                    let slice = core::slice::from_raw_parts(wasm_hash_ptr, wasm_hash_len);
                    core::str::from_utf8_unchecked(slice)
                };
                let _ = ::outlayer::storage::clear_version(wasm_hash);
            }

            /// Validate that this WASM is running in the correct project context
            ///
            /// Call this at the start of main() to ensure the WASM is being executed
            /// for the project it was built for. If OUTLAYER_PROJECT_ID is set and
            /// doesn't match, this function will panic with a clear error message.
            ///
            /// If OUTLAYER_PROJECT_ID is not set (standalone execution), validation passes.
            pub fn validate_project() {
                if let Ok(expected_project) = std::env::var("OUTLAYER_PROJECT_ID") {
                    if expected_project != PROJECT_ID {
                        panic!(
                            "Project mismatch: This WASM was built for project '{}' but is being executed for project '{}'. \
                            Please rebuild with correct metadata! {{ project: \"{}\" }}",
                            PROJECT_ID, expected_project, expected_project
                        );
                    }
                }
                // No OUTLAYER_PROJECT_ID set - standalone execution, skip validation
            }
        }

        /// Validate project context and initialize OutLayer SDK
        ///
        /// Call this at the very start of main() to:
        /// 1. Verify WASM is running in correct project (if project context exists)
        /// 2. Initialize any SDK state
        ///
        /// # Panics
        /// Panics if OUTLAYER_PROJECT_ID is set but doesn't match the project in metadata!
        ///
        /// # Example
        /// ```rust,ignore
        /// fn main() {
        ///     outlayer_init!();
        ///     // ... rest of your code
        /// }
        /// ```
        #[macro_export]
        macro_rules! outlayer_init {
            () => {
                __outlayer_metadata::validate_project();
            };
        }
    };

    TokenStream::from(expanded)
}

/// Parsed metadata input
struct MetadataInput {
    project: LitStr,
    version: LitStr,
}

impl syn::parse::Parse for MetadataInput {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let mut project = None;
        let mut version = None;

        while !input.is_empty() {
            let key: Ident = input.parse()?;
            input.parse::<Token![:]>()?;
            let value: LitStr = input.parse()?;

            match key.to_string().as_str() {
                "project" => project = Some(value),
                "version" => version = Some(value),
                other => {
                    return Err(syn::Error::new(
                        key.span(),
                        format!("unknown metadata field: {}", other),
                    ))
                }
            }

            // Optional trailing comma
            if input.peek(Token![,]) {
                input.parse::<Token![,]>()?;
            }
        }

        let project = project.ok_or_else(|| {
            syn::Error::new(proc_macro2::Span::call_site(), "missing required field: project")
        })?;

        let version = version.ok_or_else(|| {
            syn::Error::new(proc_macro2::Span::call_site(), "missing required field: version")
        })?;

        Ok(MetadataInput { project, version })
    }
}
